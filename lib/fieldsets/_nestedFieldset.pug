//- Helper javascript for the nestedFieldset mixin
-
    // A Stack to implement DFS on nested +nestedFieldset() calls
    const _nestedFieldsetStack = [];
    // A reference to the current level being processed, to build the tree while
    // walking it (we'll register the children in an attribute of this object)
    // It also indicates whether we are currently inside another +nestedFieldset()
    // or not
    let _currentNestedLevel = null;

    // prepare k-scaffold varObjects to store nested fieldset data
    varObjects.nestedFieldsets = varObjects.nestedFieldsets || {};

    // Helper function to clean up our tree structure to somehting that us JSON-able
    // by stripping PUG-runtime functions used to build the HTML
    const _nestedLevelToFieldsetLayout = function (nestedLevel) {
        const nestedLayout = {...nestedLevel};
        // Remove PUG runtime references
        delete nestedLayout.attributes;
        delete nestedLayout.block;
        // break reference cycles
        if (nestedLayout.parent) {
            nestedLayout.parent = nestedLayout.parent.qualname;
        }
        nestedLayout.children = nestedLayout.children.map(_nestedLevelToFieldsetLayout);
        return nestedLayout;
    };

    // Helper function to avoid unequal duplicate specification of nested repeating sections
    // From https://stackoverflow.com/a/52645018
    const _areObjectEquals = (a, b) => {
        if (a === b) return true;
        if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime();
        if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b;
        if (a === null || a === undefined || b === null || b === undefined) return false;
        if (a.prototype !== b.prototype) return false;
        let keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) return false;
        return keys.every(k => isEqual(a[k], b[k]));
    };

//- TODO: check level name unicity for mapping when re-design?
//- TODO: think about updates where the layout changes (need to create dummy levels?)
//- TODO: register nested fieldset in varObjects ?
mixin nestedFieldset({name, multiTopLevel=false})
    //- Argument cleanup, using actionButtonName() because used in CSS, see below
    - name = actionButtonName(name);

    //- We need to flatten the nested tree structure of the PUG into a flat list to be able
    //- to control display and styling
    //- We implement a Depth-First Search (DFS) algorithm, with the PUG resolution:
    //- 1. We can capture the content of a PUG mixin in javascript by saving the block() function.
    //-    This delays printing of the mixin content until the function is called in JS
    //- 2. Thus we can delay the resolution of nested calls to +nestedFieldset() by having the mixin
    //-    simply adding information on a stack (see the else-branch of the test below)
    //- Test if we are inside another +nestedFieldset() call
    if _currentNestedLevel === null
        //- We are not currently walking a nested structure of +nestedFieldset(), let us make a new section
        - const sectionName = name;
        //- Starts with a specific prefix because we are injecting an attribute into the author's space
        //- This should prevent any attribute name conflict
        - const selectorName = attrName(`nestedFieldsetSelector__${sectionName}`);
        -
            const nestedLevel = {
                sectionName,
                selectorName,
                parent: null,
                name,
                qualname: sectionName,
                isTopLevel: true,
                depth: (multiTopLevel ? -1 : 0),
                children: [],
                attributes,
                block,
            };

        //- Initialize our stack
        - _nestedFieldsetStack.push(nestedLevel);
        //- Container for our nested repeating section
        -
            const outerClasses = (
                "nestedFieldset" +
                ` nestedFieldset--${sectionName}` +
                " nestedFieldset__outer" +
                ` nestedFieldset--${sectionName}__outer`
            );
        div(class=outerClasses)
            +fieldset({name: sectionName})
                //- hidden input for exposing the RowID
                +hidden({name: "rowid"})
                //- Recurse into the tree-like structure and flatten it
                while _nestedFieldsetStack.length
                    //- NOTE: it is important to set the _currentNestedLevel so that children are registered
                    - _currentNestedLevel = _nestedFieldsetStack.pop();
                    +_nestedFieldsetLevel(_currentNestedLevel)
            //- Generate the Add button for the top-level level(s)
            if multiTopLevel
                //- Skip the empty top-level and add buttons for each kind of top-levels
                each children in nestedLevel.children
                    +_nestedFieldsetAddButton(children)
            else
                +_nestedFieldsetAddButton(nestedLevel)
        //- Cleanup: empty the stack (should be empty but let's be safe), clear the current level
        - _nestedFieldsetStack.splice(0);
        - _currentNestedLevel = null;
        //- Export the layout of the nested section to the sheetworkers
        -
            let nestedLayout = _nestedLevelToFieldsetLayout(nestedLevel);
            if (varObjects.nestedFieldsets.hasOwnProperty(sectionName)) {
                let previousNestedLayout = varObjects.nestedFieldsets[sectionName];
                if (!_areObjectEquals(previousNestedLayout, nestedLayout)) {
                    throw new Error(
                        `Nested fieldset '${sectionName}' has already been defined with a different layout!\n` +
                        "Previous layout:\n" +
                        `${previousNestedLayout}\n` +
                        "\n" +
                        "Conflicting layout:\n" +
                        `${nestedLayout}\n`
                    );
                }
                // Nothing to do if the layout are equal
            } else {
                varObjects.nestedFieldsets[sectionName] = nestedLayout;
            }
        - console.log(nestedLayout);
    //- END section for the top-level call to +nestedFieldset()
    else
        //- This +nestedFieldset() is inside another, let's just push the call onto the global stack
        //- and the parent level's list of children
        -
            const nestedLevel = {
                sectionName: _currentNestedLevel.sectionName,
                selectorName: _currentNestedLevel.selectorName,
                parent: _currentNestedLevel,
                name,
                qualname: actionButtonName(`${_currentNestedLevel.qualname}--${name}`),
                isTopLevel: false,
                depth: _currentNestedLevel.depth + 1,
                children: [],
                attributes,
                block,
            };
        - _currentNestedLevel.children.push(nestedLevel);
        - _nestedFieldsetStack.push(nestedLevel);


mixin _nestedFieldsetLevel(nestedLevel)
    +_nestedFieldsetToggle(nestedLevel)
    +_nestedFieldsetBlock(nestedLevel)


mixin _nestedFieldsetToggle(nestedLevel)
    -
        const class_selector = (
            "hidden" +
            " nestedFieldset__radio" +
            ` nestedFieldset--${nestedLevel.sectionName}__radio` +
            ` nestedFieldset--${nestedLevel.sectionName}__radio--${nestedLevel.qualname}`
        );
    //- NOTE: for dynamic SCSS styling based on :checked to work on radio button, there
    //-    must be a radio which is checked by default
    +radio({
        name: nestedLevel.selectorName,
        value: nestedLevel.qualname,
        class:class_selector,
        checked: (nestedLevel.isTopLevel ? "" : false)
    })


mixin _nestedFieldsetBlock(nestedLevel)
    -
        const classes = (
            "nestedFieldset__block" +
            ` nestedFieldset__block--depth_${nestedLevel.depth}` +
            ` nestedFieldset--${nestedLevel.sectionName}` +
            ` nestedFieldset--${nestedLevel.sectionName}__block--${nestedLevel.qualname}`
        );
    div(class=classes)&attributes(nestedLevel.attributes)
        +_nestedFieldsetContent(nestedLevel)
        +_nestedFieldsetAddChildren(nestedLevel)


mixin _nestedFieldsetContent(nestedLevel)
    //- Content of this specific nested level (excluding inner nested levels)
    -
        const classes = (
            "nestedFieldset__content" +
            ` nestedFieldset--${nestedLevel.sectionName}__content` +
            ` nestedFieldset--${nestedLevel.sectionName}__content--${nestedLevel.qualname}`
        );
    div(class=classes)
        //- Note: calling block() has the side-effect of putting sublevels on the stack and filling
        //-       the _currentNestedLevel `children` attribute
        //- We need a safety in case the mixin was empty, which cause block to be undefined
        - nestedLevel.block ? nestedLevel.block() : undefined;


mixin _nestedFieldsetAddChildren(nestedLevel)
    -
        const classes = (
            "nestedFieldset__buttons" +
            ` nestedFieldset--${nestedLevel.sectionName}__buttons ` +
            ` nestedFieldset--${nestedLevel.sectionName}__buttons--${nestedLevel.qualname}`
        );
    div(class=classes)
        each children in nestedLevel.children
            +_nestedFieldsetAddButton(children)


mixin _nestedFieldsetAddButton(nestedLevel)
    -
        const classes = (
            "btn" +
            " repcontrol_add" +
            " repcontrol-button" +
            " repcontrol-button--add" +
            " nestedFieldset__addButton" +
            ` nestedFieldset--${nestedLevel.sectionName}__addButton` +
            ` nestedFieldset--${nestedLevel.sectionName}__addButton--${nestedLevel.qualname}`
        )
    +action({
        name:`add---${nestedLevel.qualname}`,
        class: classes,
        trigger:{
            triggeredFuncs:['kAddNestedItem'],
            data: {
                "sectionName": nestedLevel.sectionName,
                "selectorName": nestedLevel.selectorName,
                "levelQualname": nestedLevel.qualname,
            }
        },
        "data-nested-fieldset": nestedLevel.sectionName,
        "data-nested-level": nestedLevel.qualname,
    })
        span("data-i18n"=`add---${nestedLevel.qualname}`)= nestedLevel.name
        //- span= nestedLevel.name





+module
    include _nestedFieldset.js

+scss
    include _nestedFieldset.scss